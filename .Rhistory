find.package("devtools")
install.packages ("devtools")
? install.packages
install.packages("KernSmooth")
library(KernSmooth)
find.package
find_rtools()
install.packages("devtools")
install.packages("devtools")
library(devtools)
find_rtools()
add2 <- function (x, y) {
x + y
}
add2 (3,5)
}
above <- function (x, n){
ase <- x>10
x [ase]
}
x <- 1:20
above <- function (x, n){
ase <- x>n
x [ase]
}
x <- 1:20
above (x, 12)
above <- function (x, n=10) {
use <- x >n
x [use]
}
above (x)
x <- 1:10
if (x >5){}
f <- function (x) {}
g <- function (y) {}
y+z
f<- function (x) {
g <- function(y) {
y + z
}
z <-4
x + g(x)
}
z <- 10
f(3)
y <- 10
f <- function (x) {}
f <- function (x) {}
f <- function (x) {}
y <- 10
f <- function (x) {
y <- 2
y^2 + g(x)
}
g <- function (x) {
x * y
}
f(3)
x <- 1:10
if (x>5) {
x <- 0
}
setwd
getwd
getwd()
Data <-read.csv ("001.csv")
? sub
getwd
getwd()
?rnorm
rnorm(10)
rnorm(20)
mean(rnorm(20))
x <- seq(-3,3,0.1)
plot(x=x, y=dnorm(x, mean=0, sd=1), type='l')
rnorm (10)
rnorm(20)
rnorm(20,1)
mapply(rep, 1:4, 4:1)
noise <- function(n, mean, sd)
{rnorm(n, mean, sd)}
noise(5, 1, 2)
noise(1:5, 1:5, 2)
mapply(noise, 1:5, 1:5, 2)
library(datasets)
data(iris)
?iris
getwd()
iris
iris3
tapply(iris@Sepal.Length, iris@Species == "virginica", mean)
tapply (iris$Sepal.Length, iris$Species. mean)
tapply (iris$Sepal.Length, iris$Species, mean)
m <- mean(iris$Sepal.Length[iris$Species == "virginica"])
m
colMeans(iris)
library(datasets)
data(mtcars)
?mtcars
mtcars
tapply(mpg, cyl, mean)
with(mtcars, tapply(mpg, cyl, mean))
tapply(mtcars$mpg, mtcars$cyl, mean)
x <- tapply(mtcars$hs, mtcars$cyl,mean)
x <- tapply(mtcars$hp, mtcars$cyl, mean)
x ['8'] - x['4']
$8
$'8'
lapply(mtcars$hp, mean)
saaply9mtcars$hp, mean)
sapply(mtcars$hp, mean)
debug(ls)
library(datasets)
q
help
help
undebug (ls)
undebug(ls)
undebug(ls)
?Browse
?Browse[2]
undebug(ls)
setwd("C:/Users/Miki/ProgrammingAssignment2")
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
makeCacheMatrix <- function(x = matrix()){
m <- NULL
set <- function (y) {
x <<- y
m <<- NULL
}
get <- function( ) x
setmatrix <- function (solve) m <<- solve
getmatrix <- function ( ) m
list(set = set, get = get, setmatrix = setmatrix, getmatrix = getmatrix)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
## If the inverse has already been calculated and the matrix has not changed,
## then the cachesolve should retrieve the inverse form the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getmatrix ()
if(!is.null(m)) {
message ("getting cached data")
return(m)
}
matrix <-x$get( )
m <- solve (matrix, ...)
x$setmatrix(m)
m
}
my_matrix <- makeCacheMatrix(matrix(1:4, 2,2))
my_matrix$get()
my_matrix$getmatrix()
cacheSolve(my_matrix)
